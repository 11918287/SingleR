---
title: Using SingleR to annotate single-cell RNA-seq data
author: 
- name: Aaron Lun 
- name: Jared M. Andrews
  affiliation: Washington University in St. Louis, School of Medicine, St. Louis, MO, USA
date: "Revised: 8 October 2019"
output:
  BiocStyle::html_document:
    toc_float: true
package: SingleR 
bibliography: ref.bib
vignette: >
  %\VignetteIndexEntry{Using SingleR to annotate scRNA-seq data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
---

```{r, echo=FALSE, results="hide", message=FALSE}
knitr::opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
library(BiocStyle)
```

# Introduction

`r Biocpkg("SingleR")` is an automatic annotation method for single-cell RNA sequencing (scRNAseq) data [@aran2019reference].
Given a reference dataset of samples^[This can be individual cells or bulk samples.] with known labels, it labels new cells from a test dataset based on similarity to the reference set.
Specifically, for each test cell:

1. We compute the Spearman correlation between its expression profile and that of each reference sample. 
2. We define the per-label score as a fixed quantile (by default, 0.8) of the distribution of correlations.
3. We repeat this for all labels and we take the label with the highest score as the annotation for this cell.
4. We optionally perform a fine-tuning step:
  - The reference dataset is subsetted to only include labels with scores close to the maximum.
  - Scores are recomputed using only marker genes for the subset of labels.
  - This is iterated until one label remains.

Automatic annotation provides a convenient way of transferring biological knowledge across datasets.
In this manner, the burden of interpreting clusters and defining marker genes only has to be done once.

# Demonstration on pancreas data

## Obtaining the data 

Here, we will use two human pancreas datasets from the `r Biocpkg("scRNAseq")` package [@muraro2016singlecell;@grun2016denovo].
The aim is to use one pre-labelled dataset to annotate the other unlabelled dataset.

```{r}
library(scRNAseq)
sceM <- MuraroPancreasData()
sceG <- GrunPancreasData()
```

We restrict our analysis to the common genes between the two datasets.

```{r}
common <- intersect(rownames(sceM), rownames(sceG))
sceM <- sceM[common,]
sceG <- sceG[common,]
```

One should normally do cell-based quality control at this point, but for brevity's sake, 
we will just remove the empty or unlabelled libraries here.

```{r}
sceM <- sceM[,!is.na(sceM$label)]
sceG <- sceG[,colSums(counts(sceG)) > 0]
```

We then compute the log-normalized expression values that will be used by `SingleR()` for annotation.

```{r}
library(scater)
sceM <- logNormCounts(sceM)

# Some of the cells have no spike-in counts, so we 
# set use_altexps=FALSE to avoid normalization errors.
# This is fine as we don't use the spike-ins anyway.
sceG <- logNormCounts(sceG, use_altexps=FALSE)
```

The @muraro2016singlecell dataset contains labels so we will use this as our reference dataset.

```{r}
table(sceM$label)
```

To speed up this demonstration, we will subset the @grun2016denovo dataset to the first 100 cells.

```{r}
sceG <- sceG[,1:100]
```

## Using default marker detection

The `SingleR()` function annotates each cell in a test dataset given a reference dataset with known labels.
It returns a `DataFrame` containing the predicted label for each cell and the per-label scores associated with each prediction.

```{r}
library(SingleR)
pred <- SingleR(test=sceG, ref=sceM, labels=sceM$label)
table(pred$labels)
```

By default, the `genes="de"` setting will identify markers based on pairwise comparisons between labels.
Specifically, `SingleR()` will compute the difference in the median log-expression between each pair of labels.
Markers are defined from the top set of genes with the largest positive differences in each pairwise comparison.
Correlations are then computed using only these informative genes.
Another strategy is to set `genes="sd"`, which will define markers based on the standard deviation of the median expression across labels.

## Using custom markers

Users can achieve more control of the annotation procedure by defining their own marker list.
This requires a series of pairwise comparisons between labels to define markers that distinguish each label from another.
For example, we can perform pairwise $t$-tests using `r Biocpkg("scran")` to obtain a list of lists of character vectors.
Each character vector contains the top 10 marker genes from a comparison between a pair of labels.

```{r}
library(scran)
out <- pairwiseTTests(logcounts(sceM), sceM$label, direction="up")

# To be moved into scran::topPairwiseMarkers().
markers <- list()
for (first in unique(sceM$label)) {
    cur.markers <- list()
    for (second in unique(sceM$label)) {
        chosen <- which(out$pairs$first==first & out$pairs$second==second)
        if (!length(chosen)) {
            cur.markers[[second]] <- character(0)
        } else {
            cur.stats <- out$statistics[[chosen]]
            cur.stats <- cur.stats[order(cur.stats$p.value),]
            cur.markers[[second]] <- head(rownames(cur.stats), 10)
        }
    }
    markers[[first]] <- cur.markers
}
```

We then supply these genes to `SingleR()` directly via the `genes=` argument.
This changes the results quite a bit, reflecting the importance of feature selection for this annotation method^[And many others.].
A more focused gene set also allows annotation to be performed more quickly compared to the default approach.

```{r}
pred2 <- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=markers)
table(pred$labels, pred2$labels)
```

In some cases, markers may only be available for specific labels rather than for pairwise comparisons between labels.
This is accommodated by supplying a named list of character vectors to `genes`.
Note that this is likely to be less powerful than the list-of-lists approach as information about pairwise differences is discarded.

```{r}
label.markers <- lapply(markers, unlist, recursive=FALSE)
pred3 <- SingleR(test=sceG, ref=sceM, labels=sceM$label, genes=label.markers)
table(pred$labels, pred3$labels)
```

# Visualizing annotation statistics

`r Biocpkg("SingleR")` provides a few basic yet powerful visualization tools.
We can use `plotCellVsReference()` to manually check how an individual cell in our test set compares to a reference cell of the same or different type. 
This function creates a scatter plot of the chosen cell's expression profile against the specified reference where each point is an individual gene, along with the linear regression fit and Spearman's rank correlation coefficient.

```{r}
# Get first cell label from our predictions - "acinar" in this case.
pred$labels[1]

# Get all cells in reference set with "acinar" label and plot against the first
# in this list.
same.type <- grep(pred$labels[1], sceM$label)
plotCellVsReference(sceG, test.id = 1, ref = sceM, ref.id = same.type[1])

# And now compare to a cell of a different type than our cell of interest.
diff.type <- seq_along(pred$labels)[-same.type]
plotCellVsReference(sceG, test.id = 1, ref = sceM, ref.id = diff.type[1])
```

Another useful function is `plotScoreHeatmap()`, which visualizes the scores for all cells across all reference labels.
This allows users to inspect the confidence of the predicted labels across the dataset.

```{r}
plotScoreHeatmap(pred)
```

We can also display clusters (or other metadata information) for each cell by setting the `clusters` argument. 
In this case, we also display which donor the cells came from.

```{r}
plotScoreHeatmap(pred, clusters=sceG$donor)
```

`plotScoreHeatmap()` uses `r CRANpkg("pheatmap")` for plotting, so additional arguments can be passed to adjust the heatmap as needed.

# Available reference datasets

`r Biocpkg("SingleR")` also directly provides a number of reference datasets generated from bulk RNA-seq of pure cell types.
There are two data sets from human cells (Human Primary Cell Atlas and Blueprint/ENCODE) and two data sets from mouse cells (e.g. Immunological Genome Project). For more details see the vignette dedicated to the reference data sets" `r Biocpkg("SingleR", vignette = "ReferenceDataSets")`.

Each reference dataset is obtained with a specific function: `HumanPrimaryCellAtlasData`, `BlueprintEncodeData`, `ImmGenData`, `MouseBulkData`.
Here, we show an example with data from HPCA:

```{r}
## yields a SummarizedExperiment object
hpca.se <- HumanPrimaryCellAtlasData()
```

The newly generated `SummarizedExperiment` object can then be used for the annotation of your scRNA-seq dataset.
To illustrate this, we will use a hESC dataset from `r Biocpkg("scRNAseq")` [@lamanno2016molecular].
Again, we will subset this test dataset to 100 cells for the sake of speed.

```{r}
hESCs <- scRNAseq::LaMannoBrainData('human-es')
hESCs <- hESCs[,1:100] # for demo-purposes only!
```

We then subset to genes that are present in the scRNA-seq data to be annotated and
the reference data set before we log-normalize the expression values of the hESC data set.

```{r}
## subset
common <- intersect(rownames(hESCs), rownames(hpca$data))
hpca.se <- hpca.se[common,]
hESCs <- hESCs[common,]

## normalize
hESCs <- logNormCounts(hESCs)
```

The reference data sets all come with two sets of cell labels: `label.main` and
`label.fine`. 
The "main" labels tend to be less fine-grained than the "fine" labels, e.g. instead of specifying different subsets of T cells, the main labels will lump them all together under the label "T cells". For more details about the individual cell type labels available for the different reference data sets, see the vignette `r Biocpkg("SingleR", vignette = "ReferenceDataSets")`.

For our example, we will use the more specific fine-grained cell type labels.

```{r}
pred.hpca <- SingleR(test = hESCs,
                     ref = assay(hpca.se, "normcounts"),
                     labels = hpca.se$labels.fine)
table(pred.hpca$labels)
```

# Separating training from classification

Advanced users can split the `SingleR()` workflow into two separate training and classification steps.
This means that training (e.g., marker detection, assembling of nearest-neighbor indices) only needs to be performed once.
The resulting data structures can then be re-used across multiple classifications with different test datasets, provided the test feature set is identical to or a superset of the features in the training set.
For example:

```{r}
trained <- trainSingleR(sceM, labels=sceM$label, genes=markers)
pred2b <- classifySingleR(sceG, trained)
table(pred2$labels, pred2b$labels)
```

Other efficiency improvements are possible through several arguments:

- Switching to an approximate algorithm for the nearest neighbor search in `trainSingleR()` via the `BNPARAM=` argument from the `r Biocpkg("BiocNeighbors")` package.
- Parallelizing the fine-tuning step in `classifySingleR()` with the `BPPARAM=` argument from the `r Biocpkg("BiocParallel")` package.

These arguments can also be specified in the `SingleR()` command.

# Session information

```{r}
sessionInfo()
```

# References
