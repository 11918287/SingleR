########################################################################
### Functions for the retrieval of individual data sets from ExpHub
########################################################################

#' Obtain the HPCA data
#'
#' Download and cache the normalized expression values of the data stored in
#' the Human Primary Cell Atlas. The data will be downloaded from ExperimentHub,
#' returning a \linkS4class{SummarizedExperiment} object for further use.
#'
#' @details
#' This function provides normalized expression values 713 microarray sampes of 
#' the Human Primary Cell Atlas (HPCA) (Mabbott et al., 2013).
#' These 713 samples were processed and normalized as described in Aran, Looney &
#' Liu et al. (2019) and each sample has been assigned to one of 38 main cell types
#' and 169 subtypes.
#' The cell type labels are stored in the colData of the returned \linkS4class{SummarizedExperiment}.
#'
#'
#' @return A \linkS4class{SummarizedExperiment} object.
#'
#' @author Friederike Duendar
#'
#' @references
#' Mabbott et al. (2013).
#' An expression atlas of human primary cells: Inference of gene function from coexpression networks.
#' \emph{BMC Genomics}. doi: 10.1186/1471-2164-14-632
#' 
#' Processing described in Aran, Looney & Liu et al. (2019). 
#' \emph{Nature Immunology} 20, 163–172. doi: 10.1038/s41590-018-0276-y
#' 
#' @examples
#' ref.se <- HumanPrimaryCellAtlasData()
#'
#'  \dontrun{
#' ## use the reference data to predict labels for the cells of your scRNA-seq data
#' predicted_labels <- SingleR(test = your_SCE,
#'                            training = assay(ref.se, "normcounts"), 
#'                            labels = colData(ref.se)$label.main)
#' }
#' 
#' @export
#' @importFrom SummarizedExperiment rowData
HumanPrimaryCellAtlasData <- function() {
    version <- "1.0.0"
    se <- .create_se(file.path("hpca", version),
                     assays="normcounts", rm.NA = NULL,
                     has.rowdata = FALSE, has.coldata = TRUE,
                     has.rowdata=FALSE)
}


#' Obtain human bulk RNA-seq data from Blueprint and ENCODE
#'
#' Download and cache the normalized expression values of 259 RNA-seq samples of
#' pure stroma and immune cells as generated and supplied by Blueprint and ENCODE.
#'
#' @details
#' This function provides normalized expression values of 259 bulk RNA-seq samples
#' generated by Blueprint and ENCODE from pure populations of stroma and immune 
#' cells (Martens and Stunnenberg, 2013; The ENCODE Consortium, 2012).
#'
#'  Blueprint Epigenomics: 144 RNA-seq pure immune samples annotated to 28 cell types.
#'  ENCODE: 115 RNA-seq pure stroma and immune samples annotated to 17 cell types.
#'  Altogether, 259 samples with 43 cell types.
#' 
#' The samples were processed and normalized as described in Aran, Looney &
#' Liu et al. (2019); i.e. the raw RNA-seq counts were downloaded from Blueprint
#' and ENCODE in 2016 and normalized via edgeR (TPMs).
#' 
#' The data will be downloaded from ExperimentHub,
#' returning a \linkS4class{SummarizedExperiment} object for further use.
#'
#' @param rm.NA Either one of "rows", "cols", "both", NULL to specify how missing
#' values should be handled. "rows" will remove genes with at least one missing
#' value, "cols" will remove samples with at least one missing value. Default:
#' "rows".
#'
#' @return A \linkS4class{SummarizedExperiment} object where \code{assay(..., "normcounts")}
#' contains the normalized expression values and \code{colData()} can be used to 
#' extract the cell type labels of every sample.
#'
#' @author Friederike Duendar
#'
#' @references
#' The ENCODE Project Consortium (2012).
#' An integrated encyclopedia of DNA elements in the human genome.
#' \emph{Nature}. doi: 10.1038/nature11247
#' 
#' Martens & Stunnenberg (2013). 
#' BLUEPRINT: Mapping human blood cell epigenomes.
#' \emph{Haematologica}. doi: 10.3324/haematol.2013.094243
#' 
#' Processing described in Aran, Looney & Liu et al. (2019). 
#' \emph{Nature Immunology} 20, 163–172. doi: 10.1038/s41590-018-0276-y
#' 
#' @examples
#' ref.se <- BlueprintEncodeData(rm.NA = "rows")
#' 
#' \dontrun{
#' ## use the reference data to predict labels for the cells of your scRNA-seq data
#' predicted_labels <- SingleR(test = your_SCE,
#'                            training = assay(ref.se, "normcounts"), 
#'                            labels = colData(ref.se)$label.main)
#' }
#' @export
#' 
BlueprintEncodeData <- function(rm.NA = c("rows","cols","both","none")){
    version <- "1.0.0"
    rm.NA <- match.arg(rm.NA)
    se <- .create_se(file.path("blueprint_encode", version), 
                     assays="normcounts", rm.NA = rm.NA,
                     has.rowdata = FALSE, has.coldata = TRUE)
}


#' Obtain mouse bulk expression data from the Immunologic Genome Project
#'
#' Download and cache the normalized expression values of 830 microarray samples of
#' pure mouse immune cells, generated by the Immunologic Genome Project (ImmGen).
#'
#' @details
#' This function provides normalized expression values of 830 microarray samples
#' generated by ImmGen from pure populations of murine immune cells (<http://www.immgen.org/>).
#' 
#' The samples were processed and normalized as described in Aran, Looney &
#' Liu et al. (2019); i.e. CEL files from the Gene Expression Omnibus (GEO; GSE15907 and GSE37448), 
#' were downloaded, processed, and normalized using the robust multi-array average
#' (RMA) procedure on probe-level data (with Matlab functions).
#' 
#' The data will be downloaded from ExperimentHub,
#' returning a \linkS4class{SummarizedExperiment} object for further use.
#' @return A \linkS4class{SummarizedExperiment} object where \code{assay(..., "normcounts")}
#' contains the normalized expression values and \code{colData()} can be used to 
#' extract the cell type labels of every sample.
#'
#' @author Friederike Duendar
#' 
#' @references
#' The Immunological Genome Project (2008).
#' Networks of gene expression in immune cells.
#' \emph{Nature Immunology}. doi: 10.1038/ni1008-1091
#' 
#' Processing described in Aran, Looney & Liu et al. (2019). 
#' \emph{Nature Immunology} 20, 163–172. doi: 10.1038/s41590-018-0276-y
#' 
#' @examples
#' ref.se <- ImmGenData()
#' 
#' \dontrun{
#' ## use the reference data to predict labels for the cells of your scRNA-seq data
#' predicted_labels <- SingleR(test = your_SCE,
#'                            training = assay(ref.se, "normcounts"), 
#'                            labels = colData(ref.se)$label.main)
#' }
#' @export
#' 
ImmGenData <- function(){
    version <- "1.0.0"
    se <- .create_se(file.path("immgen", version), 
                     assays="normcounts", rm.NA = NULL,
                     has.rowdata = FALSE, has.coldata = TRUE)
}


#' Obtain mouse bulk expression data of sorted cell populations (RNA-seq)
#'
#' Download and cache the normalized expression values of 358 bulk RNA-seq samples
#' of sorted cell populations that can be found at GEO.
#'
#' @details This dataset was contributed by the Benayoun Lab that identified, 
#' downloaded and processed data sets on GEO that corresponded to sorted cell
#' types (Benayoun et al., 2019).
#' 
#' The dataset entails 358 mouse RNA-seq samples annotated to 18 main cell types: 
#' Adipocytes, Astrocytes, B cells, Cardiomyocytes, Dendritic cells, Endothelial 
#' cells, Epithelial cells, Erythrocytes, Fibroblasts, Granulocytes, Hepatocytes,
#' Macrophages, Microglia, Monocytes, Neurons, NK cells, Oligodendrocytes, T cells.
#' 
#' @return A \linkS4class{SummarizedExperiment} object where \code{assay(..., "normcounts")}
#' contains the normalized expression values and \code{colData()} can be used to 
#' extract the cell type labels of every sample.
#'
#' @author Friederike Duendar
#' 
#' @references
#' Benayoun B et al. (2019).
#' Remodeling of epigenome and transcriptome landscapes with aging in mice reveals widespread induction of inflammatory responses.
#' \emph{Genome Research}. doi: 10.1101/gr.240093.118
#' 
#' @examples
#' ref.se <- MouseBulkData()
#' 
#' \dontrun{
#' ## use the reference data to predict labels for the cells of your scRNA-seq data
#' predicted_labels <- SingleR(test = your_SCE,
#'                            training = assay(ref.se, "normcounts"), 
#'                            labels = colData(ref.se)$label.main)
#' }                  
#' @export
#' 
MouseBulkData <- function(){
    version <- "1.0.0"
    se <- .create_se(file.path("mouse.rnaseq", version), 
                     assays="normcounts", rm.NA = NULL,
                     has.rowdata = FALSE, has.coldata = TRUE)
}


#####################################################################
### Helper function
#####################################################################

#' Create a SummarizedExperiment object using data from ExperimentHub
#' 
#' @param dataset string indicating the name of the reference data set to be
#' retrieved. Choices are: c("hpca", "blueprint_encode", "immgen", "mouse.rnaseq")
#' @param rm.NA indicate how to handle NA's. Valid choices are "rows" (remove
#' genes with at least one missing value), "cols" (remove samples with at least
#' one missing value), "both" (remove samples as well as genes that have at least
#' one missing value, respectively), "none" or NULL.
#' 
#' @importFrom ExperimentHub ExperimentHub
#' @importFrom SummarizedExperiment SummarizedExperiment
#' @importFrom SummarizedExperiment rowData
.create_se <- function(dataset = c("hpca", "blueprint_encode", "immgen", "mouse.rnaseq"),
                       hub = ExperimentHub(), assays="normcounts",
                       rm.NA = c("rows","cols","both","none"),
                       has.rowdata=FALSE, has.coldata=TRUE) {
    
    ## TEMPORARY CODE for pulling data directly from github until it is 
    ## available on ExHub =====================================================
    ref.set <- getReferenceDataset(dataset=dataset)
    nrmcnts <- ref.set$data
    colnames(nrmcnts) <- paste(colnames(nrmcnts), 1:ncol(nrmcnts), sep = ".")
    
    ## handling NA's
    if(!is.null(rm.NA)){
        rm.NA <- match.arg(rm.NA)
        nrmcnts <- .rm_NAs(nrmcnts, rm.NA)
    }
    
    ## defining colDAta
    coldata <- S4Vectors::DataFrame(row.names = colnames(nrmcnts),
                                    label.main = ref.set$main_types,
                                    label.fine = ref.set$types)
    ref.se <- SummarizedExperiment(assays = list(normcounts = nrmcnts),
                                   colData = coldata)
    
    return(ref.se)
    
    ##########################################################################
    ## code for when data is actually available on ExpHub ===================
    ##########################################################################
    host <- file.path("SingleR", dataset)
    
    ## extract normalized values --------
    all.assays <- list()
    for (a in assays) {
        nrmcnts <- hub[hub$rdatapath==file.path(host, sprintf("%s%s.rds", a, suffix))][[1]]
        
        if(!is.null(rm.NA)){
            rm.NA <- match.arg(rm.NA)
            nrmcnts <- .rm_NAs(nrmcnts, rm.NA)
        }
        all.assays[[a]] <- nrmcnts
    }
    
    ## get metadata ----------------------
    args <- list()
    if (has.coldata) {
        args$colData <- hub[hub$rdatapath==file.path(host, sprintf("coldata%s.rds", suffix))][[1]]
    }
    if (has.rowdata) {
        args$rowData <- hub[hub$rdatapath==file.path(host, sprintf("rowdata%s.rds", suffix))][[1]]
    }
    
    ## make the final SE object ----------
    do.call(SummarizedExperiment, c(list(assays=all.assays), args))
}


#' Handle NAs in expression matrix
#' 
#' @param mat matrix of expression values
#' @param rm.NA choices: "rows", "cols", "both"
.rm_NAs <- function(mat, rm.NA = "rows"){
    if(rm.NA == "rows" | rm.NA == "both"){
        keep_rows <- apply(mat, 1, function(x) all(!is.na(x)))
        if( length(keep_rows[keep_rows]) > 0){
            mat <- mat[keep_rows, ]
        }else{
            warning("The number of rows (genes) with NAs equals the *total* number of genes. We're going to ignore your wish to eliminate rows with NAs.")
        }
        
    }
    
    if(rm.NA == "cols" | rm.NA == "both"){
        keep_cols <- apply(mat, 2, function(x) all(!is.na(x)))
        if( length(keep_cols[keep_cols]) > 0){
            mat <- mat[ , keep_cols]
        }else{
            warning("The number of columns (samples) with NAs equals the *total* number of samples. We're going to ignore your wish to eliminate columns with NAs.")
        }
    }
    
    return(mat)
}
